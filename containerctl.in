#!/bin/sh -efu

. shell-error
. shell-var
. shell-quote
. shell-git-config

container="@SBINDIR@/container"
configdir="@CONFIG@/container"

cfg="$configdir/config.ini"

show_help()
{
	cat <<-EOF
	Usage: $PROG {start|stop|status|restart} [NAME ...]

	Options:
	   -V, --version   output version information and exit;
	   -h, --help      display this help and exit.

	Report bugs to authors.

	EOF
	exit
}

print_version()
{
	cat <<-EOF
	$PROG version @VERSION@
	Written by Alexey Gladkov.

	Copyright (C) 2018  Alexey Gladkov <gladkov.alexey@gmail.com>
	This is free software; see the source for copying conditions.  There is NO
	warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	EOF
	exit
}

show_usage()
{
	[ -z "$*" ] || message "$*"
	echo "Try \`$PROG --help' for more information." >&2
	exit 1
}

split_comma()
{
	local s IFS=', 	'
	while read s; do
		printf '%s\n' $s
	done
}

join_arg()
{
	local arg="$1"; shift
	local a res=
	for a; do
		res="$res,$a"
	done
	[ -z "${res#,}" ] || printf "%s=%s" "$arg" "${res#,}"
}

get_bool()
{
	local location rc=1 v
	for location; do
		git_config_location_exists "$cfg" "$location" ||
			continue
		git_config_get v "$cfg" "$location"
		shell_var_is_yes "$v" && rc=0 || rc=1
	done
	return $rc
}

parse_config()
{

	cfg_verbose=
	! get_bool 'global.verbose' "container.$1.verbose" ||
		cfg_verbose=1

	git_config_get cfg_rootdir "$cfg" "container.$1.rootdir"
	git_config_get cfg_uid     "$cfg" "container.$1.uid"
	git_config_get cfg_gid     "$cfg" "container.$1.gid"
	git_config_get cfg_init    "$cfg" "container.$1.init"
	git_config_get cfg_stdout  "$cfg" "container.$1.stdout"
	git_config_get cfg_stdin   "$cfg" "container.$1.stdin"
	git_config_get cfg_restart "$cfg" "container.$1.restart"

	cfg_cap_add="$(git_config_list "$cfg" "container.$1.cap-add" |split_comma)"
	cfg_cap_drop="$(git_config_list "$cfg" "container.$1.cap-drop" |split_comma)"
	cfg_unshare="$(git_config_list "$cfg" "container.$1.unshare" |split_comma)"
}

conntainer_exec()
{
	[ -z "$cfg_stdin" ] && [ -z "$cfg_stdout" ] ||
		eval exec ${cfg_stdin:+<"$cfg_stdin"} ${cfg_stdout:+>"$cfg_stdout" 2>&1}

	while :; do
		rc=0
		"$container" "$@" -- "$cfg_rootdir" ${cfg_init:-/bin/sh} || rc=$?

		[ -n "$cfg_restart" ] ||
			break
	done

	rm -rf -- "$cfg_lockdir/$name" >/dev/null 2>&1 ||:

	exit $rc
}

start()
{
	parse_config "$name"

	if [ ! -d "$cfg_rootdir" ]; then
		printf "Container %s do not have root directory.\n" "$name"
		return 1
	fi

	if ! mkdir -m700 "$cfg_lockdir/$name" >/dev/null 2>&1; then
		printf "Container %s is already running.\n" "$name"
		return 0
	fi

	local initenv=/.initrd/initenv initargs args=

	if [ -s "$initenv" ]; then
		. "$initenv"
		read initargs < /.initrd/initargs
	fi

	args="$args ${cfg_verbose:+-v}"
	args="$args ${cfg_uid:+--uid=$cfg_uid}"
	args="$args ${cfg_gid:+--gid=$cfg_gid}"
	args="$args $(join_arg --unshare  $cfg_unshare)"
	args="$args $(join_arg --cap-drop $cfg_cap_drop)"
	args="$args $(join_arg --cap-add  $cfg_cap_add)"

	[ ! -f "$configdir/$name/fstab"   ] || args="$args --mount='$configdir/$name/fstab'"
	[ ! -f "$configdir/$name/environ" ] || args="$args --environ='$configdir/$name/environ'"
	[ ! -f "$configdir/$name/devices" ] || args="$args --devices='$configdir/$name/devices'"

	quote_shell_args args "$args"
	eval "set -- $args"

	[ -d "$cg_freezer/$name" ] || mkdir -- "$cg_freezer/$name" ||
		return

	local  CONTAINER_HOOK_PRERUN="$cfg_lockdir/$name/hook.pre"
	export CONTAINER_HOOK_PRERUN

	printf '#!/bin/sh -efu\necho $CONTAINER_PID > %s\n' "$cg_tasks" > "$CONTAINER_HOOK_PRERUN"
	chmod +x -- "$CONTAINER_HOOK_PRERUN"

	if [ -n "$cfg_stdin" ]; then
		(conntainer_exec "$@") &
	else
		(conntainer_exec "$@")
		stop
	fi
}

stop()
{
	if [ ! -d "$cg_freezer/$name" ]; then
		printf "Container %s is not running.\n" "$name"
		return 1
	fi

	echo FROZEN >"$cg_state"

	local status pid

	status=
	while [ "$status" != FROZEN ]; do
		read status < "$cg_state"
		sleep 0.1
	done

	while read pid; do
		kill -9 "$pid"
	done < "$cg_tasks"

	echo THAWED >"$cg_state"

	while :; do
		read pid < "$cg_tasks" || break
		sleep 0.1
	done

	rmdir -- "$cg_freezer/$name" ||
		return

	rm -rf -- "$cfg_lockdir/$name" >/dev/null 2>&1 ||:
}

status()
{
	local pid

	[ -f "$cg_tasks" ] && read pid < "$cg_tasks" ||
		return 1
}

TEMP=`getopt -n $PROG -o 'h,V' -l 'help,version' -- "$@"` ||
	show_usage
eval set -- "$TEMP"

while :; do
	case "$1" in
		-h|--help)
			show_help
			;;
		-V|--version)
			print_version
			;;
		--) shift
			break
			;;
		*)
			fatal "Unknown option: $1"
			;;
	esac
	shift
done

[ "$#" != 0 ] || show_usage
[ "$#" -ge 2 ] || show_usage "Error: more arguments required"

action="$1"; shift

[ -s "$cfg" ] ||
	fatal "config file not found: $cfg"

git_config_get cfg_lockdir "$cfg" "global.lockdir"
git_config_get cfg_cgroupsdir "$cfg" "global.cgroupsdir"

[ -n "$cfg_lockdir" ] || cfg_lockdir="/var/tmp"
[ -n "$cfg_cgroupsdir" ] || cfg_cgroupsdir='/sys/fs/cgroup'

mountpoint -q "$cfg_cgroupsdir" ||
	mount -t tmpfs tmpfs "$cfg_cgroupsdir"

cg_freezer="$cfg_cgroupsdir/freezer"

if [ ! -d "$cg_freezer" ]; then
	mkdir -- "$cg_freezer"
	mount -t cgroup -o freezer freezer "$cg_freezer"
fi

rc=0
for name; do
	cg_state="$cg_freezer/$name/freezer.state"
	cg_tasks="$cg_freezer/$name/tasks"

	case "$action" in
		start)
			start || rc=$?
			;;
		stop)
			stop || rc=$?
			;;
		restart)
			stop && start || rc=$?
			;;
		status)
			if status; then
				s=running
			else
				rc=1
				s=stopped

				[ ! -d "$cfg_lockdir/$name" ] || {
					rc=2
					s=dead
				}
			fi
			printf "Container %s is %s.\n" "$name" "$s"
			;;
		*)
			show_usage "Error: unknown action: $action"
			;;
	esac
done

exit $rc
